//===- InlineFunction.cpp - Code to perform function inlining -------------===//
//
// This file implements inlining of a function into a call site, resolving
// parameters and the return value as appropriate.
//
// FIXME: This pass should transform alloca instructions in the called function
//        into malloc/free pairs!  Or perhaps it should refuse to inline them!
//
//===----------------------------------------------------------------------===//

#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Constant.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Module.h"
#include "llvm/Instructions.h"
#include "llvm/Intrinsics.h"
#include "llvm/Support/CallSite.h"
#include "llvm/Transforms/Utils/Local.h"

bool InlineFunction(CallInst *CI) { return InlineFunction(CallSite(CI)); }
bool InlineFunction(InvokeInst *II) { return InlineFunction(CallSite(II)); }

// InlineFunction - This function inlines the called function into the basic
// block of the caller.  This returns false if it is not possible to inline this
// call.  The program is still in a well defined state if this occurs though.
//
// Note that this only does one level of inlining.  For example, if the 
// instruction 'call B' is inlined, and 'B' calls 'C', then the call to 'C' now 
// exists in the instruction stream.  Similiarly this will inline a recursive
// function by one level.
//
bool InlineFunction(CallSite CS) {
  Instruction *TheCall = CS.getInstruction();
  assert(TheCall->getParent() && TheCall->getParent()->getParent() &&
         "Instruction not in function!");

  const Function *CalledFunc = CS.getCalledFunction();
  if (CalledFunc == 0 ||          // Can't inline external function or indirect
      CalledFunc->isExternal() || // call, or call to a vararg function!
      CalledFunc->getFunctionType()->isVarArg()) return false;

  BasicBlock *OrigBB = TheCall->getParent();
  Function *Caller = OrigBB->getParent();

  // We want to clone the entire callee function into the whole between the
  // "starter" and "ender" blocks.  How we accomplish this depends on whether
  // this is an invoke instruction or a call instruction.

  BasicBlock *InvokeDest = 0;     // Exception handling destination
  BasicBlock *AfterCallBB;
  if (InvokeInst *II = dyn_cast<InvokeInst>(TheCall)) {
    AfterCallBB = II->getNormalDest();
    InvokeDest = II->getExceptionalDest();

    // Add an unconditional branch to make this look like the CallInst case...
    new BranchInst(AfterCallBB, TheCall);

    // Remove (unlink) the InvokeInst from the function...
    OrigBB->getInstList().remove(TheCall);
  } else {  // It's a call
    // If this is a call instruction, we need to split the basic block that the
    // call lives in.
    //
    AfterCallBB = OrigBB->splitBasicBlock(TheCall,
                                          CalledFunc->getName()+".entry");
    // Remove (unlink) the CallInst from the function...
    AfterCallBB->getInstList().remove(TheCall);
  }

  // If we have a return value generated by this call, convert it into a PHI 
  // node that gets values from each of the old RET instructions in the original
  // function.
  //
  PHINode *PHI = 0;
  if (!TheCall->use_empty()) {
    // The PHI node should go at the front of the new basic block to merge all 
    // possible incoming values.
    //
    PHI = new PHINode(CalledFunc->getReturnType(), TheCall->getName(),
                      AfterCallBB->begin());

    // Anything that used the result of the function call should now use the PHI
    // node as their operand.
    //
    TheCall->replaceAllUsesWith(PHI);
  }

  // Get an iterator to the last basic block in the function, which will have
  // the new function inlined after it.
  //
  Function::iterator LastBlock = &Caller->back();

  // Calculate the vector of arguments to pass into the function cloner...
  std::map<const Value*, Value*> ValueMap;
  assert(std::distance(CalledFunc->abegin(), CalledFunc->aend()) == 
         std::distance(CS.arg_begin(), CS.arg_end()) &&
         "No varargs calls can be inlined!");

  CallSite::arg_iterator AI = CS.arg_begin();
  for (Function::const_aiterator I = CalledFunc->abegin(), E=CalledFunc->aend();
       I != E; ++I, ++AI)
    ValueMap[I] = *AI;

  // Since we are now done with the Call/Invoke, we can delete it.
  delete TheCall;

  // Make a vector to capture the return instructions in the cloned function...
  std::vector<ReturnInst*> Returns;

  // Populate the value map with all of the globals in the program.
  // FIXME: This should be the default for CloneFunctionInto!
  Module &M = *Caller->getParent();
  for (Module::iterator I = M.begin(), E = M.end(); I != E; ++I)
    ValueMap[I] = I;
  for (Module::giterator I = M.gbegin(), E = M.gend(); I != E; ++I)
    ValueMap[I] = I;

  // Do all of the hard part of cloning the callee into the caller...
  CloneFunctionInto(Caller, CalledFunc, ValueMap, Returns, ".i");

  // Loop over all of the return instructions, turning them into unconditional
  // branches to the merge point now...
  for (unsigned i = 0, e = Returns.size(); i != e; ++i) {
    ReturnInst *RI = Returns[i];
    BasicBlock *BB = RI->getParent();

    // Add a branch to the merge point where the PHI node lives if it exists.
    new BranchInst(AfterCallBB, RI);

    if (PHI) {   // The PHI node should include this value!
      assert(RI->getReturnValue() && "Ret should have value!");
      assert(RI->getReturnValue()->getType() == PHI->getType() && 
             "Ret value not consistent in function!");
      PHI->addIncoming(RI->getReturnValue(), BB);
    }

    // Delete the return instruction now
    BB->getInstList().erase(RI);
  }

  // Check to see if the PHI node only has one argument.  This is a common
  // case resulting from there only being a single return instruction in the
  // function call.  Because this is so common, eliminate the PHI node.
  //
  if (PHI && PHI->getNumIncomingValues() == 1) {
    PHI->replaceAllUsesWith(PHI->getIncomingValue(0));
    PHI->getParent()->getInstList().erase(PHI);
  }

  // Change the branch that used to go to AfterCallBB to branch to the first
  // basic block of the inlined function.
  //
  TerminatorInst *Br = OrigBB->getTerminator();
  assert(Br && Br->getOpcode() == Instruction::Br && 
	 "splitBasicBlock broken!");
  Br->setOperand(0, ++LastBlock);

  // If there are any alloca instructions in the block that used to be the entry
  // block for the callee, move them to the entry block of the caller.  First
  // calculate which instruction they should be inserted before.  We insert the
  // instructions at the end of the current alloca list.
  //
  if (isa<AllocaInst>(LastBlock->begin())) {
    BasicBlock::iterator InsertPoint = Caller->begin()->begin();
    while (isa<AllocaInst>(InsertPoint)) ++InsertPoint;
    
    for (BasicBlock::iterator I = LastBlock->begin(), E = LastBlock->end();
         I != E; )
      if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {
        ++I;  // Move to the next instruction
        LastBlock->getInstList().remove(AI);
        Caller->front().getInstList().insert(InsertPoint, AI);      
      } else {
        ++I;
      }
  }

  // If we just inlined a call due to an invoke instruction, scan the inlined
  // function checking for function calls that should now be made into invoke
  // instructions, and for llvm.exc.rethrow()'s which should be turned into
  // branches.
  if (InvokeDest)
    for (Function::iterator BB = LastBlock, E = Caller->end(); BB != E; ++BB)
      for (BasicBlock::iterator I = BB->begin(), E = BB->end(); I != E; ) {
        // We only need to check for function calls: inlined invoke instructions
        // require no special handling...
        if (CallInst *CI = dyn_cast<CallInst>(I)) {
          // FIXME: this should use annotations of the LLVM functions themselves
          // to determine whether or not the function can throw.
          bool ShouldInvokify = true;
          
          if (Function *F = CI->getCalledFunction())
            if (unsigned ID = F->getIntrinsicID())
              if (ID == LLVMIntrinsic::exc_rethrow) {
                // llvm.exc.rethrow requires special handling when it gets
                // inlined into an invoke site.  Once this happens, we know that
                // the rethrow would cause a control transfer to the invoke
                // exception destination, so we can transform it into a direct
                // branch to the exception destination.
                BranchInst *BI = new BranchInst(InvokeDest, CI);

                // Note that since any instructions after the rethrow/branch are
                // dead, we must delete them now (otherwise the terminator we
                // just inserted wouldn't be at the end of the basic block!)
                BasicBlock *CurBB = BB;
                while (&CurBB->back() != BI) {
                  Instruction *I = &CurBB->back();
                  if (!I->use_empty())
                    I->replaceAllUsesWith(Constant::getNullValue(I->getType()));
                  CurBB->getInstList().pop_back();
                }

                break;  // Done with this basic block!
              } else if (ID == LLVMIntrinsic::exc_throw ||
                         ID == LLVMIntrinsic::exc_getcurrent) {
                ShouldInvokify = false; // Not correct to invokify exc.throw!
              }
          
          // If we should convert this function into an invoke instruction, do
          // so now.
          if (ShouldInvokify) {
            // First, split the basic block...
            BasicBlock *Split = BB->splitBasicBlock(CI, CI->getName()+".noexc");
            
            // Next, create the new invoke instruction, inserting it at the end
            // of the old basic block.
            new InvokeInst(CI->getCalledValue(), Split, InvokeDest, 
                           std::vector<Value*>(CI->op_begin()+1, CI->op_end()),
                           CI->getName(), BB->getTerminator());

            // Delete the unconditional branch inserted by splitBasicBlock
            BB->getInstList().pop_back();
            Split->getInstList().pop_front();  // Delete the original call
            
            // This basic block is now complete, start scanning the next one.
            break;
          } else {
            ++I;
          }
        } else {
          ++I;
        }
      }

  // Now that the function is correct, make it a little bit nicer.  In
  // particular, move the basic blocks inserted from the end of the function
  // into the space made by splitting the source basic block.
  //
  Caller->getBasicBlockList().splice(AfterCallBB, Caller->getBasicBlockList(), 
                                     LastBlock, Caller->end());

  // We should always be able to fold the entry block of the function into the
  // single predecessor of the block...
  assert(cast<BranchInst>(Br)->isUnconditional() && "splitBasicBlock broken!");
  BasicBlock *CalleeEntry = cast<BranchInst>(Br)->getSuccessor(0);
  SimplifyCFG(CalleeEntry);
  
  // Okay, continue the CFG cleanup.  It's often the case that there is only a
  // single return instruction in the callee function.  If this is the case,
  // then we have an unconditional branch from the return block to the
  // 'AfterCallBB'.  Check for this case, and eliminate the branch is possible.
  SimplifyCFG(AfterCallBB);
  return true;
}

//===-- X86RegisterInfo.def - X86 Register Information ----------*- C++ -*-===//
//
// This file describes all of the registers that the X86 backend uses. It relies
// on an external 'R' macro being defined that takes the arguments specified
// below, and is used to make all of the information relevant to registers be in
// one place.
//
//===----------------------------------------------------------------------===//

// NOTE: No include guards desired

#ifndef R
#errror "Must define R macro before including X86/X86RegisterInfo.def!"
#endif

// Arguments passed into the R macro
//  #1: Enum Name - This ends up being a symbol in the X86 namespace
//  #2: Register name - The name of the register as used by the gnu assembler
//  #3: Register Flags - A bitfield of flags or'd together from the
//      MRegisterInfo.h file.
//  #4: Target Specific Flags - Another bitfield containing X86 specific flags
//      as neccesary.


// The first register must always be a 'noop' register for all backends.  This
// is used as the destination register for instructions that do not produce a
// value.  Some frontends may use this as an operand register to mean special
// things, for example, the Sparc backend uses R#0 to mean %g0 which always
// PRODUCES the value 0.
//
// The X86 backend uses this value as an operand register only in memory
// references where it means that there is no base or index register.
//
R(NoReg, "none", 0, 0)


// 32 bit registers, ordered as the processor does...
R(EAX, "EAX", MRF::INT32, 0)
R(ECX, "ECX", MRF::INT32, 0)
R(EDX, "EDX", MRF::INT32, 0)
R(EBX, "EBX", MRF::INT32, 0)
R(ESP, "ESP", MRF::INT32, 0)
R(EBP, "EBP", MRF::INT32, 0)
R(ESI, "ESI", MRF::INT32, 0)
R(EDI, "EDI", MRF::INT32, 0)

// 16 bit registers, aliased with the corresponding 32 bit registers above
R(AX, "AX", MRF::INT16, 0)
R(CX, "CX", MRF::INT16, 0)
R(DX, "DX", MRF::INT16, 0)
R(BX, "BX", MRF::INT16, 0)
R(SP, "SP", MRF::INT16, 0)
R(BP, "BP", MRF::INT16, 0)
R(SI, "SI", MRF::INT16, 0)
R(DI, "DI", MRF::INT16, 0)

// 8 bit registers aliased with registers above as well
R(AL, "AL", MRF::INT8, 0)
R(CL, "CL", MRF::INT8, 0)
R(DL, "DL", MRF::INT8, 0)
R(BL, "BL", MRF::INT8, 0)
R(AH, "AH", MRF::INT8, 0)
R(CH, "CH", MRF::INT8, 0)
R(DH, "DH", MRF::INT8, 0)
R(BH, "BH", MRF::INT8, 0)

// Flags, Segment registers, etc...

// This is a slimy hack to make it possible to say that flags are clobbered...
// Ideally we'd model instructions based on which particular flag(s) they
// could clobber. 
R(EFLAGS, "EFLAGS", MRF::INT16, 0)

// We are now done with the R macro
#undef R

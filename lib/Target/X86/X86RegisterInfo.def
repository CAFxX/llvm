//===-- X86RegisterInfo.def - X86 Register Information ----------*- C++ -*-===//
//
// This file describes all of the registers that the X86 backend uses. It relies
// on an external 'R' macro being defined that takes the arguments specified
// below, and is used to make all of the information relevant to registers be in
// one place.
//
//===----------------------------------------------------------------------===//

// NOTE: No include guards desired
#ifndef R
#define R(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET)
#endif

#ifndef R8
#define R8(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET) \
   R(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET)
#endif

#ifndef R16
#define R16(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET) \
   R(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET)
#endif

#ifndef R32
#define R32(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET) \
   R(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET)
#endif

// Pseudo Floating Point registers
#ifndef PFP
#define PFP(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET) \
   R(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET)
#endif

// Floating Point Stack registers
#ifndef FPS
#define FPS(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET) \
   R(ENUM, NAME, FLAGS, TSFLAGS, ALIAS_SET)
#endif

// Arguments passed into the R macros
//  #1: Enum Name - This ends up being a symbol in the X86 namespace
//  #2: Register name - The name of the register as used by the gnu assembler
//  #3: Register Flags - A bitfield of flags or'd together from the
//      MRegisterInfo.h file.
//  #4: Target Specific Flags - Another bitfield containing X86 specific flags
//      as necessary.
//  #5: Alias set for registers aliased to this register (sets defined below).


// The first register must always be a 'noop' register for all backends.  This
// is used as the destination register for instructions that do not produce a
// value.  Some frontends may use this as an operand register to mean special
// things, for example, the Sparc backend uses R#0 to mean %g0 which always
// PRODUCES the value 0.
//
// The X86 backend uses this value as an operand register only in memory
// references where it means that there is no base or index register.
//
R(NoReg,"none",          0, 0, 0/*noalias*/)

// 32 bit registers, ordered as the processor does...
R32(EAX, "EAX", MRF::INT32, 0, A_EAX)
R32(ECX, "ECX", MRF::INT32, 0, A_ECX)
R32(EDX, "EDX", MRF::INT32, 0, A_EDX)
R32(EBX, "EBX", MRF::INT32, 0, A_EBX)
R32(ESP, "ESP", MRF::INT32, 0, A_ESP)
R32(EBP, "EBP", MRF::INT32, 0, A_EBP)
R32(ESI, "ESI", MRF::INT32, 0, A_ESI)
R32(EDI, "EDI", MRF::INT32, 0, A_EDI)

// 16 bit registers, aliased with the corresponding 32 bit registers above
R16( AX, "AX" , MRF::INT16, 0, A_AX)
R16( CX, "CX" , MRF::INT16, 0, A_CX)
R16( DX, "DX" , MRF::INT16, 0, A_DX)
R16( BX, "BX" , MRF::INT16, 0, A_BX)
R16( SP, "SP" , MRF::INT16, 0, A_SP)
R16( BP, "BP" , MRF::INT16, 0, A_BP)
R16( SI, "SI" , MRF::INT16, 0, A_SI)
R16( DI, "DI" , MRF::INT16, 0, A_DI)

// 8 bit registers aliased with registers above as well
R8 ( AL, "AL" , MRF::INT8 , 0, A_AL)
R8 ( CL, "CL" , MRF::INT8 , 0, A_CL)
R8 ( DL, "DL" , MRF::INT8 , 0, A_DL)
R8 ( BL, "BL" , MRF::INT8 , 0, A_BL)
R8 ( AH, "AH" , MRF::INT8 , 0, A_AH)
R8 ( CH, "CH" , MRF::INT8 , 0, A_CH)
R8 ( DH, "DH" , MRF::INT8 , 0, A_DH)
R8 ( BH, "BH" , MRF::INT8 , 0, A_BH)

// Pseudo Floating Point Registers
PFP(FP0, "FP0", MRF::FP80 , 0, 0 /*noalias*/)
PFP(FP1, "FP1", MRF::FP80 , 0, 0 /*noalias*/)
PFP(FP2, "FP2", MRF::FP80 , 0, 0 /*noalias*/)
PFP(FP3, "FP3", MRF::FP80 , 0, 0 /*noalias*/)
PFP(FP4, "FP4", MRF::FP80 , 0, 0 /*noalias*/)
PFP(FP5, "FP5", MRF::FP80 , 0, 0 /*noalias*/)
PFP(FP6, "FP6", MRF::FP80 , 0, 0 /*noalias*/)

// Floating point stack registers
FPS(ST0, "ST(0)", MRF::FP80, 0, 0)
FPS(ST1, "ST(1)", MRF::FP80, 0, 0)
FPS(ST2, "ST(2)", MRF::FP80, 0, 0)
FPS(ST3, "ST(3)", MRF::FP80, 0, 0)
FPS(ST4, "ST(4)", MRF::FP80, 0, 0)
FPS(ST5, "ST(5)", MRF::FP80, 0, 0)
FPS(ST6, "ST(6)", MRF::FP80, 0, 0)
FPS(ST7, "ST(7)", MRF::FP80, 0, 0)

// Flags, Segment registers, etc...

// This is a slimy hack to make it possible to say that flags are clobbered...
// Ideally we'd model instructions based on which particular flag(s) they
// could clobber. 
R(EFLAGS, "EFLAGS", MRF::INT16, 0, 0 /*noalias*/)


//===----------------------------------------------------------------------===//
// Register alias set handling...
//

// Macro to handle definitions of alias sets that registers use...
#ifndef ALIASLIST
#define ALIASLIST(NAME, ...)
#endif

ALIASLIST(A_EAX     , X86::AX, X86::AH, X86::AL, 0)
ALIASLIST(A_ECX     , X86::CX, X86::CH, X86::CL, 0)
ALIASLIST(A_EDX     , X86::DX, X86::DH, X86::DL, 0)
ALIASLIST(A_EBX     , X86::BX, X86::BH, X86::BL, 0)
ALIASLIST(A_ESP     , X86::SP, 0)
ALIASLIST(A_EBP     , X86::BP, 0)
ALIASLIST(A_ESI     , X86::SI, 0)
ALIASLIST(A_EDI     , X86::DI, 0)
ALIASLIST(A_AX      , X86::EAX, X86::AH, X86::AL, 0)
ALIASLIST(A_CX      , X86::ECX, X86::CH, X86::CL, 0)
ALIASLIST(A_DX      , X86::EDX, X86::DH, X86::DL, 0)
ALIASLIST(A_BX      , X86::EBX, X86::BH, X86::BL, 0)
ALIASLIST(A_SP      , X86::ESP, 0)
ALIASLIST(A_BP      , X86::EBP, 0)
ALIASLIST(A_SI      , X86::ESI, 0)
ALIASLIST(A_DI      , X86::EDI, 0)
ALIASLIST(A_AL      , X86::EAX, X86::AX, 0)
ALIASLIST(A_CL      , X86::ECX, X86::CX, 0)
ALIASLIST(A_DL      , X86::EDX, X86::DX, 0)
ALIASLIST(A_BL      , X86::EBX, X86::BX, 0)
ALIASLIST(A_AH      , X86::EAX, X86::AX, 0)
ALIASLIST(A_CH      , X86::ECX, X86::CX, 0)
ALIASLIST(A_DH      , X86::EDX, X86::DX, 0)
ALIASLIST(A_BH      , X86::EBX, X86::BX, 0)
#undef ALIASLIST

// We are now done with the R* macros
#undef R
#undef R8
#undef R16
#undef R32
#undef PFP
#undef FPS

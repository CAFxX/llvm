//===-- X86RegisterInfo.def - X86 Register Information ----------*- C++ -*-===//
//
// This file describes all of the registers that the X86 backend uses. It relies
// on an external 'R' macro being defined that takes the arguments specified
// below, and is used to make all of the information relevant to registers be in
// one place.
//
//===----------------------------------------------------------------------===//

// NOTE: No include guards desired
#ifndef R
#errror "Must define R macro before including X86/X86RegisterInfo.def!"
#endif

#ifndef R8
#define R8(ENUM, NAME, FLAGS, TSFLAGS) R(ENUM, NAME, FLAGS, TSFLAGS)
#endif

#ifndef R16
#define R16(ENUM, NAME, FLAGS, TSFLAGS) R(ENUM, NAME, FLAGS, TSFLAGS)
#endif

#ifndef R32
#define R32(ENUM, NAME, FLAGS, TSFLAGS) R(ENUM, NAME, FLAGS, TSFLAGS)
#endif

// Arguments passed into the R macro
//  #1: Enum Name - This ends up being a symbol in the X86 namespace
//  #2: Register name - The name of the register as used by the gnu assembler
//  #3: Register Flags - A bitfield of flags or'd together from the
//      MRegisterInfo.h file.
//  #4: Target Specific Flags - Another bitfield containing X86 specific flags
//      as neccesary.


// The first register must always be a 'noop' register for all backends.  This
// is used as the destination register for instructions that do not produce a
// value.  Some frontends may use this as an operand register to mean special
// things, for example, the Sparc backend uses R#0 to mean %g0 which always
// PRODUCES the value 0.
//
// The X86 backend uses this value as an operand register only in memory
// references where it means that there is no base or index register.
//
R(NoReg, "none", 0, 0)

// 32 bit registers, ordered as the processor does...
R32(EAX, "EAX", MRF::INT32, 0)
R32(ECX, "ECX", MRF::INT32, 0)
R32(EDX, "EDX", MRF::INT32, 0)
R32(EBX, "EBX", MRF::INT32, 0)
R32(ESP, "ESP", MRF::INT32, 0)
R32(EBP, "EBP", MRF::INT32, 0)
R32(ESI, "ESI", MRF::INT32, 0)
R32(EDI, "EDI", MRF::INT32, 0)

// 16 bit registers, aliased with the corresponding 32 bit registers above
R16(AX, "AX", MRF::INT16, 0)
R16(CX, "CX", MRF::INT16, 0)
R16(DX, "DX", MRF::INT16, 0)
R16(BX, "BX", MRF::INT16, 0)
R16(SP, "SP", MRF::INT16, 0)
R16(BP, "BP", MRF::INT16, 0)
R16(SI, "SI", MRF::INT16, 0)
R16(DI, "DI", MRF::INT16, 0)

// 8 bit registers aliased with registers above as well
R8(AL, "AL", MRF::INT8, 0)
R8(CL, "CL", MRF::INT8, 0)
R8(DL, "DL", MRF::INT8, 0)
R8(BL, "BL", MRF::INT8, 0)
R8(AH, "AH", MRF::INT8, 0)
R8(CH, "CH", MRF::INT8, 0)
R8(DH, "DH", MRF::INT8, 0)
R8(BH, "BH", MRF::INT8, 0)

// Flags, Segment registers, etc...

// This is a slimy hack to make it possible to say that flags are clobbered...
// Ideally we'd model instructions based on which particular flag(s) they
// could clobber. 
R(EFLAGS, "EFLAGS", MRF::INT16, 0)

// We are now done with the R* macros
#undef R
#undef R8
#undef R16
#undef R32

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>LLVM Bytecode File Format</title>
  <link rel="stylesheet" href="llvm.css" type="text/css">
  <style type="css">
    table, tr, td { border: 2px solid gray }
    th { border: 2px solid gray; font-weight: bold; }
    table { border-collapse: collapse; margin-top: 1em margin-bottom: 1em }
  </style>
</head>
<body>
  <div class="doc_title"> LLVM Bytecode File Format </div>
<ol>
  <li><a href="#abstract">Abstract</a></li>
  <li><a href="#general">General Concepts</a>
    <ol>
      <li><a href="#blocks">Blocks</a></li>
      <li><a href="#lists">Lists</a></li>
      <li><a href="#fields">Fields</a></li>
      <li><a href="#slots">Slots</a></li>
      <li><a href="#encoding">Encoding Rules</a></li>
      <li><a href="#align">Alignment</a></li>
    </ol>
  </li>
  <li><a href="#details">Detailed Layout</a>
    <ol>
      <li><a href="#notation">Notation</a></li>
      <li><a href="#blocktypes">Blocks Types</a></li>
      <li><a href="#signature">Signature Block</a></li>
      <li><a href="#module">Module Block</a></li>
      <li><a href="#typeool">Global Type Pool</a></li>
      <li><a href="#modinfo">Module Info Block</a></li>
      <li><a href="#constants">Global Constant Pool</a></li>
      <li><a href="#functions">Function Blocks</a></li>
      <li><a href="#symtab">Module Symbol Table</a></li>
    </ol>
  </li>
  <li><a href="#versiondiffs">Version Differences</a>
    <ol>
      <li><a href="#vers12">Version 1.2 Differences From 1.3</a></li>
      <li><a href="#vers11">Version 1.1 Differences From 1.2</a></li>
      <li><a href="#vers10">Version 1.0 Differences From 1.1</a></li>
    </ol>
  </li>
</ol>
<div class="doc_author">
<p>Written by <a href="mailto:rspencer@x10sys.com">Reid Spencer</a>
</p>
</div>
<div class="doc_warning">
  <p>Warning: This is a work in progress.</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="abstract">Abstract </a></div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This document describes the LLVM bytecode
file format. It specifies the binary encoding rules of the bytecode file format
so that equivalent systems can encode bytecode files correctly.  The LLVM 
bytecode representation is used to store the intermediate representation on 
disk in compacted form.
</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="general">General Concepts</a> </div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section describes the general concepts of the bytecode file format 
without getting into bit and byte level specifics.  Note that the LLVM bytecode
format may change in the future, but will always be backwards compatible with
older formats.  This document only describes the most current version of the
bytecode format.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="blocks">Blocks</a> </div>
<div class="doc_text">
<p>LLVM bytecode files consist simply of a sequence of blocks of bytes. 
Each block begins with an identification value that determines the type of 
the next block.  The possible types of blocks are described below in the section 
<a href="#blocktypes">Block Types</a>. The block identifier is used because
it is possible for entire blocks to be omitted from the file if they are
empty. The block identifier helps the reader determine which kind of block is
next in the file.</p>
<p>The following block identifiers are currently in use 
(from llvm/Bytecode/Format.h):</p>
<ol>
  <li><b>Module (0x01)</b>.</li>
  <li><b>Function (0x11)</b>.</li>
  <li><b>ConstantPool (0x12)</b>.</li>
  <li><b>SymbolTable (0x13)</b>.</li>
  <li><b>ModuleGlobalInfo (0x14)</b>.</li>
  <li><b>GlobalTypePlane (0x15)</b>.</li>
  <li><b>BasicBlock (0x31)</b>.</li>
  <li><b>InstructionList (0x32)</b>.</li>
  <li><b>CompactionTable (0x33)</b>.</li>
</ol>
<p> All blocks are variable length, and the block header specifies the size of 
the block.  All blocks are rounded aligned to even 32-bit boundaries, so they 
always start and end of this boundary.  Each block begins with an integer 
identifier and the length of the block, which does not include the padding 
bytes needed for alignment.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="lists">Lists</a> </div>
<div class="doc_text">
<p>Most blocks are constructed of lists of information. Lists can be constructed
of other lists, etc. This decomposition of information follows the containment
hierarchy of the LLVM Intermediate Representation. For example, a function 
contains a list of instructions (the terminator instructions implicitly define 
the end of the basic blocks).</p>
<p>A list is encoded into the file simply by encoding the number of entries as
an integer followed by each of the entries. The reader knows when the list is
done because it will have filled the list with the required numbe of entries.
</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="fields">Fields</a> </div>
<div class="doc_text">
<p>Fields are units of information that LLVM knows how to write atomically.
Most fields have a uniform length or some kind of length indication built into
their encoding. For example, a constant string (array of bytes) is
written simply as the length followed by the characters. Although this is 
similar to a list, constant strings are treated atomically and are thus
fields.</p>
<p>Fields use a condensed bit format specific to the type of information
they must contain. As few bits as possible are written for each field. The
sections that follow will provide the details on how these fields are 
written and how the bits are to be interpreted.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="slots">Slots</a> </div>
<div class="doc_text">
<p>The bytecode format uses the notion of a "slot" to reference Types and
Values. Since the bytecode file is a <em>direct</em> representation of LLVM's
intermediate representation, there is a need to represent pointers in the file.
Slots are used for this purpose. For example, if one has the following assembly:
</p>

<div class="doc_code">
  %MyType = type { int, sbyte }<br>
  %MyVar = external global %MyType
</div>

<p>there are two definitions. The definition of <tt>%MyVar</tt> uses 
<tt>%MyType</tt>. In the C++ IR this linkage between <tt>%MyVar</tt> and 
<tt>%MyType</tt> is
explicit through the use of C++ pointers. In bytecode, however, there's no
ability to store memory addresses. Instead, we compute and write out slot 
numbers for every type and Value written to the file.</p>
<p>A slot number is simply an unsigned 32-bit integer encoded in the variable
bit rate scheme (see <a href="#encoding">encoding</a> below). This ensures that
low slot numbers are encoded in one byte. Through various bits of magic LLVM
attempts to always keep the slot numbers low. The first attempt is to associate
slot numbers with their "type plane". That is, Values of the same type are 
written to the bytecode file in a list (sequentially). Their order in that list
determines their slot number. This means that slot #1 doesn't mean anything
unless you also specify for which type you want slot #1. Types are handled
specially and are always written to the file first (in the Global Type Pool) and
in such a way that both forward and backward references of the types can often be
resolved with a single pass through the type pool. </p>
<p>Slot numbers are also kept small by rearranging their order. Because of the
structure of LLVM, certain values are much more likely to be used frequently
in the body of a function. For this reason, a compaction table is provided in
the body of a function if its use would make the function body smaller. 
Suppose you have a function body that uses just the types "int*" and "{double}"
but uses them thousands of time. Its worthwhile to ensure that the slot number
for these types are low so they can be encoded in a single byte (via vbr).
This is exactly what the compaction table does.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="encoding">Encoding Primitives</a> </div>
<div class="doc_text">
<p>Each field that can be put out is encoded into the file using a small set 
of primitives. The rules for these primitives are described below.</p>
<h3>Variable Bit Rate Encoding</h3>
<p>Most of the values written to LLVM bytecode files are small integers.  To 
minimize the number of bytes written for these quantities, an encoding
scheme similar to UTF-8 is used to write integer data. The scheme is known as
variable bit rate (vbr) encoding.  In this encoding, the high bit of each 
byte is used to indicate if more bytes follow. If (byte &amp; 0x80) is non-zero 
in any given byte, it means there is another byte immediately following that 
also contributes to the value. For the final byte (byte &amp; 0x80) is false 
(the high bit is not set). In each byte only the low seven bits contribute to 
the value. Consequently 32-bit quantities can take from one to <em>five</em> 
bytes to encode. In general, smaller quantities will encode in fewer bytes, 
as follows:</p>
<table class="doc_table_nw">
  <tr>
    <th>Byte #</th>
    <th>Significant Bits</th>
    <th>Maximum Value</th>
  </tr>
  <tr><td>1</td><td>0-6</td><td>127</td></tr>
  <tr><td>2</td><td>7-13</td><td>16,383</td></tr>
  <tr><td>3</td><td>14-20</td><td>2,097,151</td></tr>
  <tr><td>4</td><td>21-27</td><td>268,435,455</td></tr>
  <tr><td>5</td><td>28-34</td><td>34,359,738,367</td></tr>
  <tr><td>6</td><td>35-41</td><td>4,398,046,511,103</td></tr>
  <tr><td>7</td><td>42-48</td><td>562,949,953,421,311</td></tr>
  <tr><td>8</td><td>49-55</td><td>72,057,594,037,927,935</td></tr>
  <tr><td>9</td><td>56-62</td><td>9,223,372,036,854,775,807</td></tr>
  <tr><td>10</td><td>63-69</td><td>1,180,591,620,717,411,303,423</td></tr>
</table>
<p>Note that in practice, the tenth byte could only encode bit 63 
since the maximum quantity to use this encoding is a 64-bit integer.</p>

<p><em>Signed</em> VBR values are encoded with the standard vbr encoding, but 
with the sign bit as the low order bit instead of the high order bit.  This 
allows small negative quantities to be encoded efficiently.  For example, -3
is encoded as "((3 &lt;&lt; 1) | 1)" and 3 is encoded as "(3 &lt;&lt; 1) | 
0)", emitted with the standard vbr encoding above.</p>

<p>The table below defines the encoding rules for type names used in the
descriptions of blocks and fields in the next section. Any type name with
the suffix <em>_vbr</em> indicate a quantity that is encoded using 
variable bit rate encoding as described above.</p>
<table class="doc_table" >
  <tr>
    <th><b>Type</b></th>
    <th align="left"><b>Rule</b></th>
  </tr>
  <tr>
    <td>unsigned</td>
    <td align="left">A 32-bit unsigned integer that always occupies four 
      consecutive bytes. The unsigned integer is encoded using LSB first 
      ordering. That is bits 2<sup>0</sup> through 2<sup>7</sup> are in the 
      byte with the lowest file offset (little endian).</td>
  </tr><tr>
    <td>uint_vbr</td>
    <td align="left">A 32-bit unsigned integer that occupies from one to five 
    bytes using variable bit rate encoding.</td>
  </tr><tr>
    <td>uint64_vbr</td>
    <td align="left">A 64-bit unsigned integer that occupies from one to ten 
    bytes using variable bit rate encoding.</td>
  </tr><tr>
    <td>int64_vbr</td>
    <td align="left">A 64-bit signed integer that occupies from one to ten 
    bytes using the signed variable bit rate encoding.</td>
  </tr><tr>
    <td>char</td>
    <td align="left">A single unsigned character encoded into one byte</td>
  </tr><tr>
    <td>bit</td>
    <td align="left">A single bit within a byte.</td>
  </tr><tr>
    <td>string</td>
    <td align="left">A uint_vbr indicating the length of the character string 
    immediately followed by the characters of the string. There is no 
    terminating null byte in the string.</td>
  </tr><tr>
    <td>data</td>
    <td align="left">An arbitrarily long segment of data to which no 
    interpretation is implied. This is used for float, double, and constant 
    initializers.</td>
  </tr>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="align">Alignment</a> </div>
<div class="doc_text">
<p>To support cross-platform differences, the bytecode file is aligned on 
certain boundaries. This means that a small amount of padding (at most 3 bytes) 
will be added to ensure that the next entry is aligned to a 32-bit boundary.
</p>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="details">Detailed Layout</a> </div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section provides the detailed layout of the LLVM bytecode file format.
bit and byte level specifics.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="notation">Notation</a></div>
<div class="doc_text">
  <p>The descriptions of the bytecode format that follow describe the bit
  fields in detail. These descriptions are provided in tabular form. Each table
  has four columns that specify:</p>
  <ol>
    <li><b>Byte(s)</b>: The offset in bytes of the field from the start of
    its container (block, list, other field).</li>
    <li><b>Bit(s)</b>: The offset in bits of the field from the start of
    the byte field. Bits are always little endian. That is, bit addresses with
    smaller values have smaller address (i.e. 2<sup>0</sup> is at bit 0, 
    2<sup>1</sup> at 1, etc.)
    </li>
    <li><b>Align?</b>: Indicates if this field is aligned to 32 bits or not.
    This indicates where the <em>next</em> field starts, always on a 32 bit
    boundary.</li>
    <li><b>Type</b>: The basic type of information contained in the field.</li>
    <li><b>Description</b>: Describes the contents of the field.</li>
  </ol>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="blocktypes">Block Types</a></div>
<div class="doc_text">
  <p>The bytecode format encodes the intermediate representation into groups
  of bytes known as blocks. The blocks are written sequentially to the file in
  the following order:</p>
<ol>
  <li><a href="#signature">Signature</a>: This contains the file signature 
  (magic number) that identifies the file as LLVM bytecode and the bytecode 
  version number.</li>
  <li><a href="#module">Module Block</a>: This is the top level block in a
  bytecode file. It contains all the other blocks.</li>
  <li><a href="#gtypepool">Global Type Pool</a>: This block contains all the
  global (module) level types.</li>
  <li><a href="#modinfo">Module Info</a>: This block contains the types of the
  global variables and functions in the module as well as the constant
  initializers for the global variables</li>
  <li><a href="#constants">Constants</a>: This block contains all the global
  constants except function arguments, global values and constant strings.</li>
  <li><a href="#functions">Functions</a>: One function block is written for
  each function in the module. </li>
  <li><a href="#symtab">Symbol Table</a>: The module level symbol table that
  provides names for the various other entries in the file is the final block 
  written.</li>
</ol>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="signature">Signature Block</a> </div>
<div class="doc_text">
<p>The signature occurs in every LLVM bytecode file and is always first.
It simply provides a few bytes of data to identify the file as being an LLVM
bytecode file. This block is always four bytes in length and differs from the
other blocks because there is no identifier and no block length at the start
of the block. Essentially, this block is just the "magic number" for the file.
<table class="doc_table_nw" >
  <tr>
    <th><b>Byte(s)</b></th>
    <th><b>Bit(s)</b></th>
    <th><b>Align?</b></th>
    <th><b>Type</b></th>
    <th align="left"><b>Field Description</b></th>
  </tr><tr>
    <td>00</td><td>-</td><td>No</td><td>char</td>
    <td align="left">Constant "l" (0x6C)</td>
  </tr><tr>
    <td>01</td><td>-</td><td>No</td><td>char</td>
    <td align="left">Constant "l" (0x6C)</td>
  </tr><tr>
    <td>02</td><td>-</td><td>No</td><td>char</td>
    <td align="left">Constant "v" (0x76)</td>
  </tr><tr>
    <td>03</td><td>-</td><td>No</td><td>char</td>
    <td align="left">Constant "m" (0x6D)</td>
  </tr>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="module">Module Block</a> </div>
<div class="doc_text">
<p>The module block contains a small pre-amble and all the other blocks in
the file. Of particular note, the bytecode format number is simply a 28-bit
monotonically increase integer that identifiers the version of the bytecode
format (which is not directly related to the LLVM release number).  The 
bytecode versions defined so far are (note that this document only describes 
the latest version): </p>

<ul>
<li>#0: LLVM 1.0 &amp; 1.1</li>
<li>#1: LLVM 1.2</li>
<li>#2: LLVM 1.3</li>
</ul>

<p>The table below shows the format of the module block header. It is defined 
by blocks described in other sections.</p>
<table class="doc_table_nw" >
  <tr>
    <th><b>Byte(s)</b></th>
    <th><b>Bit(s)</b></th>
    <th><b>Align?</b></th>
    <th><b>Type</b></th>
    <th align="left"><b>Field Description</b></th>
  </tr><tr>
    <td>04-07</td><td>-</td><td>No</td><td>unsigned</td>
    <td align="left">Module Identifier (0x01)</td>
  </tr><tr>
    <td>08-11</td><td>-</td><td>No</td><td>unsigned</td>
    <td align="left">Size of the module block in bytes</td>
  </tr><tr>
    <td>12-15</td><td>00</td><td>Yes</td><td>uint32_vbr</td>
    <td align="left">Format Information</td>
  </tr><tr>
    <td>''</td><td>0</td><td>-</td><td>bit</td>
    <td align="left">Big Endian?</td>
  </tr><tr>
    <td>''</td><td>1</td><td>-</td><td>bit</td>
    <td align="left">Pointers Are 64-bit?</td>
  </tr><tr>
    <td>''</td><td>2</td><td>-</td><td>bit</td>
    <td align="left">Has No Endianess?</td>
  </tr><tr>
    <td>''</td><td>3</td><td>-</td><td>bit</td>
    <td align="left">Has No Pointer Size?</td>
  </tr><tr>
    <td>''</td><td>4-31</td><td>-</td><td>bit</td>
    <td align="left">Bytecode Format Version</td>
  </tr><tr>
    <td>16-end</td><td>-</td><td>-</td><td>blocks</td>
    <td align="left">The remaining bytes in the block consist
    solely of other block types in sequence.</td>
  </tr>
</table>

<p>Note that we plan to eventually expand the target description capabilities
of bytecode files to <a href="http://llvm.cs.uiuc.edu/PR263">target 
triples</a>.</p>

</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="gtypepool">Global Type Pool</a> </div>
<div class="doc_text">
<p>The global type pool consists of type definitions. Their order of appearance
in the file determines their slot number (0 based). Slot numbers are used to 
replace pointers in the intermediate representation. Each slot number uniquely
identifies one entry in a type plane (a collection of values of the same type).
Since all values have types and are associated with the order in which the type
pool is written, the global type pool <em>must</em> be written as the first 
block of a module. If it is not, attempts to read the file will fail because
both forward and backward type resolution will not be possible.</p>
<p>The type pool is simply a list of types definitions, as shown in the table 
below.</p>
<table class="doc_table_nw" >
  <tr>
    <th><b>Byte(s)</b></th>
    <th><b>Bit(s)</b></th>
    <th><b>Align?</b></th>
    <th><b>Type</b></th>
    <th align="left"><b>Field Description</b></th>
  </tr><tr>
    <td>00-03</td><td>-</td><td>No</td><td>unsigned</td>
    <td align="left">Type Pool Identifier (0x13)</td>
  </tr><tr>
    <td>04-07</td><td>-</td><td>No</td><td>unsigned</td>
    <td align="left">Size in bytes of the symbol table block.</td>
  </tr><tr>
    <td>08-11<sup>1</sup></td><td>-</td><td>No</td><td>uint32_vbr</td>
    <td align="left">Number of entries in type plane</td>
  </tr><tr>
    <td>12-15<sup>1</sup></td><td>-</td><td>No</td><td>uint32_vbr</td>
    <td align="left">Type plane index for following entries</td>
  </tr><tr>
    <td>16-end<sup>1,2</sup></td><td>-</td><td>No</td><td>type</td>
    <td align="left">Each of the type definitions.</td>
  </tr><tr>
    <td align="left" colspan="5"><sup>1</sup>Maximum length shown, 
      may be smaller<br><sup>2</sup>Repeated field.
  </tr>
</table>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="modinfo">Module Info</a> </div>
<div class="doc_text">
  <p>To be determined.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="constants">Constants</a> </div>
<div class="doc_text">
  <p>To be determined.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="functions">Functions</a> </div>
<div class="doc_text">
  <p>To be determined.</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection"><a name="symtab">Symbol Table</a> </div>
<div class="doc_text">
<p>A symbol table can be put out in conjunction with a module or a function.
A symbol table is a list of type planes. Each type plane starts with the number
of entries in the plane and the type plane's slot number (so the type can be 
looked up in the global type pool). For each entry in a type plane, the slot 
number of the value and the name associated with that value are written.  The 
format is given in the table below. </p>
<table class="doc_table_nw" >
  <tr>
    <th><b>Byte(s)</b></th>
    <th><b>Bit(s)</b></th>
    <th><b>Align?</b></th>
    <th><b>Type</b></th>
    <th align="left"><b>Field Description</b></th>
  </tr><tr>
    <td>00-03</td><td>-</td><td>No</td><td>unsigned</td>
    <td align="left">Symbol Table Identifier (0x13)</td>
  </tr><tr>
    <td>04-07</td><td>-</td><td>No</td><td>unsigned</td>
    <td align="left">Size in bytes of the symbol table block.</td>
  </tr><tr>
    <td>08-11<sup>1</sup></td><td>-</td><td>No</td><td>uint32_vbr</td>
    <td align="left">Number of entries in type plane</td>
  </tr><tr>
    <td>12-15<sup>1</sup></td><td>-</td><td>No</td><td>uint32_vbr</td>
    <td align="left">Type plane index for following entries</td>
  </tr><tr>
    <td>16-19<sup>1,2</sup></td><td>-</td><td>No</td><td>uint32_vbr</td>
    <td align="left">Slot number of a value.</td>
  </tr><tr>
    <td>variable<sup>1,2</sup></td><td>-</td><td>No</td><td>string</td>
    <td align="left">Name of the value in the symbol table.</td>
  </tr>
  <tr>
    <td align="left" colspan="5"><sup>1</sup>Maximum length shown, 
      may be smaller<br><sup>2</sup>Repeated field.
  </tr>
</table>
</div>
<!-- *********************************************************************** -->
<div class="doc_section"> <a name="versiondiffs">Version Differences</a> </div>
<!-- *********************************************************************** -->
<div class="doc_text">
<p>This section describes the differences in the Bytecode Format across LLVM
versions. The versions are listed in reverse order because it assumes the 
current version is as documented in the previous sections. Each section here
describes the differences between that version and the one that <i>follows</i>
</p>
</div>
<!-- _______________________________________________________________________ -->
<div class="doc_subsection">
<a name="vers12">Version 1.2 Differences From 1.3</a></div>
<div class="doc_text">
<p>TBD: How version 1.2 differs from version 1.3</p>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection">
<a name="vers11">Version 1.1 Differences From 1.2 </a></div>
<div class="doc_text">
<p>TBD: How version 1.1 differs from version 1.2</p>
</div>

<!-- _______________________________________________________________________ -->
<div class="doc_subsection">
<a name="vers11">Version 1.0 Differences From 1.1</a></div>
<div class="doc_text">
<p>TBD: How version 1.0 differs from version 1.1</p>
</div>

<!-- *********************************************************************** -->
<hr>
<address>
  <a href="http://jigsaw.w3.org/css-validator/check/referer"><img
  src="http://jigsaw.w3.org/css-validator/images/vcss" alt="Valid CSS!"></a>
  <a href="http://validator.w3.org/check/referer"><img
  src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!" /></a>

  <a href="mailto:rspencer@x10sys.com">Reid Spencer</a> and 
  <a href="mailto:sabre@nondot.org">Chris Lattner</a><br>
  <a href="http://llvm.cs.uiuc.edu">The LLVM Compiler Infrastructure</a><br>
  Last modified: $Date$
</address>
</body>
</html>
<!-- vim: sw=2
-->
